\documentclass{article}

\usepackage{url}

\setlength{\parskip}{1em}
\renewcommand{\baselinestretch}{1.2}

\begin{document}
  \title{Revisiting the Lisp Operating System in the 21st century}
  \author{Tom Hutchings}

  \maketitle

  \section{Introduction}
  \iffalse
  memory has increased massively
  show language marketshare, point out GC and interpreted languages, i.e. GC usage is viable
  but what about in an OS

  memory sharing hard
  lisp nice UI, fast development


  document split into sections describing the prior research in the topics this project touches on,
  the proposed implementation, resources required
  \fi
  
  In 1960, while he was at MIT, John McCarthy published the paper ``Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I''\cite{MccarthyJohn1960Rfos}, describing a new programming language Lisp, a simple language which operated on Linked List data structures. A few years later, to the suprise of McCarthy, an interpreter for the language was implemented on the IBM 704, allowing Lisp programs, written in the S-Expression format described in the paper, to be executed on a real machine. Lisp was radically different to the other languages of the time, with dynamic types, linked lists as a built in data type, and the possibility to program in a functional style. Not long after, an incremental Lisp compiler/interpreter was implemented in Lisp, the first of its kind, was implemented for use in the MIT AI Lab~\cite{ai-memo-39}, allowing Lisp to acheive higher speed than before. This was the beginning of Lisp's golden era, where it experienced wide usage in AI research.
  \par
  However, the world of computing moved on to smaller microcomputers and PCs, and Lisp could not keep up with the new world where speed and memory usage were stricter. Dedicated machines to run Lisp were created by MIT Staff, and even sold for business use by the companies LMI and Genera, but in the newly developing personal computing world the language was still constrained by its reliance on a garbage collector to run on smaller systems. This would allow for a lower memory usage, but required the program to pause periodically to `clean up' its memory.
  \par
  According the TIOBE Index, an index of the most popular programming languages in a given year, the top 10 languages for 2019 are Java, C, Python, C++, C\#, Visual Basic .NET, JavaScript, SQL, PHP, and Objective-C. Of these 10, 6 are languages that utillize Garbage Collection to manage their memory. Garbage Collected languages such as these are widespread for all kinds of application programming. Even high performance web servers can be written in such languages. 

  \section{Background}
  \iffalse
  show old lisp problems with gc and perf (p558-bobrow, )
  
  show relevant GC research (p103-yang, )
  
  show lisp/functional distributed research
  \fi

  As Lisp became widely used amongst the AI research community, difficulties began to surface as the machines that Lisp was implemented upon were being stretched beyond their capabilities. The key issues were a lack of available addresseable memory and lack of computing power. One solution devised was to implement a new machine, with a new instruction set entirely geared towards running Lisp programs~TODO:re-cite earlier paper~\cite{knight-lisp}. However this approach is no longer applicable in the 21st century, Lisp machines are long gone, and Intels x86 architecture dominant amongst both the personal computer and server market. Instead we can take the principles that the Lisp machines used to optimize their execution and apply them to an implementation on the x86 architecture.
  
  Efforts were also made at improving Lisps performance by trying to optimize the garbage collectors of the time\cite{WhiteJon1987Amfa}, 
  \par
  In \textit{The Future of Lisp, 2002}, Takeuichi claimed that if real time Garbage Collection technology matured further, then Lisp has the potential to be a good systems programming language~\cite{TakeuchiIkuo2002TfoL}. With the rise in popularity of Java since its release in 1995, the interest in using the language real time applications has grown, necessitating research into the development of a real time garbage collector for Java\cite{SiebertF.2010Cprg}\cite{SchoeberlMartin2010Nrgc}\cite{KaliberaTomas2011Srgc}. This research could help to optimize the garbage collector implementation in the proposed project, allowing more systems code to be written in Lisp, facilitating a microkernel architecture.
  \par
  \textit{Yang et al} described the implementation of a virtual memory system specifically to support garbage collected software\cite{Yang:2006:CVM:1298455.1298466}. This could prove very useful for implemenation of the OS, as full control over how virtual memory is managed and allocated will be possible in the kernel, allowing the memory system to be optimized fully for a Lisp interpreter.
  \par
  Gifford and Lacussen described a programming language where both \textit{type checking} and \textit{side effect checking} are performed~\cite{Gifford:1986:IFI:319838.319848}

  
  \section{Proposed Project}
  \iffalse
  OS with a lisp interpreter embedded in the kernel
  same model as emacs, C core, Lisp everything else

  why lisp? can be functional and imperative, in kernel repl, \\
  excellent ast manipulation and code gen (JIT and language support) \\
  safe language, removes needs for mem protection the same way

  process model splitting code and env \\
  heirarchical env layering between processes ensures safety \\
  env for low level, requires special permissions \\

  use mem layering to help concurrent GC

  \begin{itemize}
  \item Minimum Spec \\
    basic OS, with multitasking and shell interface, LISP repl in kernel
  \item Mid Spec \\
    LISP process model, simple gui, filesystem, mark and sweep gc
  \item Ultra DX Re:Master Spec \\
    dual LISP code / JITed code process model, JIT compiler in kernel, concurrent gc
  \end{itemize}
  \fi

  TODO: WE/I propose an Operating System designed from the start to facilitate the execution of Lisp in its userspace, with a core microkernel written in C. The kernel shall incorporate a Lisp intepreter, and apply modern techniques for memory allocation and garbage collection to optimize execution of Lisp programs.
  \par
  A key aspect of Lisp is the \textit{Environment} or \textit{Env}, an associative data structure containing mappings from \textit{Symbols}, such as variables and functions, to their values, whether they are literal values such as Integers, or a function body, stored as a list. We can look at this Environment structure in the context of processes, and novel methods of memory protection can be conceived, such as allowing child processes to access the environment of their parent but with read only access.
  \par
  The Env could also allow for easier runtime typechecking and enforcement, as each entry in the Env data structure can contain type information.
  \par

  In short, the project should meet these key requirements.
  \begin{itemize}
  \item A core multitasking kernel written in C to facilitate low level functions and booting.
  \item A Lisp intereter running in kernel space which can interpret arbitary Lisp code.
  \item A means for Lisp code running in userspace to interact with the kernel, such as system calls.
  \end{itemize}

  With this basic operating system implemented, research on applying techniques to optimize areas like virtual memory, garbage collection, and the interpreter.

  \section{Programme of Work}
  TODO: gantt chart

  \section{Resources Required}
  emacs

  
  \bibliographystyle{ieeetr}
  \bibliography{bib/proposal}
\end{document}