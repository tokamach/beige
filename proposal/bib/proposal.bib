%% This BibTeX bibliography file was created using BibDesk.
%% http://bibdesk.sourceforge.net/

%% Created for Tom Hutchings at 2019-10-25 14:35:16 +0100 


%% Saved with string encoding Unicode (UTF-8) 



@misc{tiobe-index,
	Date-Added = {2019-10-25 14:28:08 +0100},
	Date-Modified = {2019-10-25 14:28:44 +0100},
	Howpublished = {\url{https://www.tiobe.com/tiobe-index/}},
	Title = {TIOBE Index}}

@inproceedings{YeeJ.J1993Spmi,
	Abstract = {<p>In a system supporting parallel execution, speculative processing can be used to increase the amount of parallelism. The authors propose a speculative execution scheme for the data-driven Lisp machine BIDDLE. Execution priorities are assigned to instructions according to their nested position in conditional statements. These priorities are updated dynamically during execution as results of Boolean guards of conditional execution are returned. The authors describe the ways to maintain the environment and handle side effects and tuplespace in the speculative context. Each speculative branch is given a separate environment. Any side-effects made are merged into the environment of the calling instruction when the speculation is confirmed, and removed if they are unwanted. It is also demonstrated that infinite data structures can be supported by this scheme.<<ETX>></p>},
	Author = {Yee, J.J and Feng, M.D and Yuen, C.K},
	Booktitle = {[1993] Proceedings of the Twenty-sixth Hawaii International Conference on System Sciences},
	Date-Added = {2019-10-25 13:17:43 +0100},
	Date-Modified = {2019-10-25 13:17:43 +0100},
	Isbn = {0818632305},
	Issn = {15301605},
	Keywords = {Data Structures},
	Language = {eng},
	Pages = {457--465 vol.1},
	Publisher = {IEEE},
	Title = {Speculative processing mechanisms in a parallel Lisp machine: BIDDLE},
	Volume = {i},
	Year = {1993}}

@inproceedings{Golm:2002:JOS:647057.713870,
	Acmid = {713870},
	Address = {Berkeley, CA, USA},
	Author = {Golm, Michael and Felser, Meik and Wawersich, Christian and Klein\"{o}der, J\"{u}rgen},
	Booktitle = {Proceedings of the General Track of the Annual Conference on USENIX Annual Technical Conference},
	Date-Added = {2019-10-25 12:15:47 +0100},
	Date-Modified = {2019-10-25 12:15:47 +0100},
	Isbn = {1-880446-00-6},
	Numpages = {14},
	Pages = {45--58},
	Publisher = {USENIX Association},
	Series = {ATEC '02},
	Title = {The JX Operating System},
	Url = {http://dl.acm.org/citation.cfm?id=647057.713870},
	Year = {2002},
	Bdsk-Url-1 = {http://dl.acm.org/citation.cfm?id=647057.713870}}

@article{hunt2007singularity,
	Abstract = {Every operating system embodies a collection of design decisions. Many of the decisions behind today's most popular operating systems have remained unchanged, even as hardware and software have evolved. Operating systems form the foundation of almost every software stack, so inadequacies in present systems have a pervasive impact. This paper describes the efforts of the Singularity project to re-examine these design choices in light of advances in programming languages and verification tools. Singularity systems incorporate three key architectural features: software-isolated processes for protection of programs and system services, contract-based channels for communication, and manifest-based programs for verification of system properties. We describe this foundation in detail and sketch the ongoing research in experimental systems that build upon it.},
	Author = {Hunt, Galen and Larus, Jim},
	Date-Added = {2019-10-25 12:14:19 +0100},
	Date-Modified = {2019-10-25 12:14:19 +0100},
	Journal = {ACM SIGOPS Operating Systems Review},
	Month = {April},
	Number = {2},
	Pages = {37-49},
	Publisher = {Association for Computing Machinery, Inc.},
	Title = {Singularity: Rethinking the Software Stack},
	Url = {https://www.microsoft.com/en-us/research/publication/singularity-rethinking-the-software-stack/},
	Volume = {41},
	Year = {2007},
	Bdsk-Url-1 = {https://www.microsoft.com/en-us/research/publication/singularity-rethinking-the-software-stack/}}

@inproceedings{Gifford:1986:IFI:319838.319848,
	Acmid = {319848},
	Address = {New York, NY, USA},
	Author = {Gifford, David K. and Lucassen, John M.},
	Booktitle = {Proceedings of the 1986 ACM Conference on LISP and Functional Programming},
	Date-Added = {2019-10-25 00:16:16 +0100},
	Date-Modified = {2019-10-25 00:16:16 +0100},
	Doi = {10.1145/319838.319848},
	Isbn = {0-89791-200-4},
	Location = {Cambridge, Massachusetts, USA},
	Numpages = {11},
	Pages = {28--38},
	Publisher = {ACM},
	Series = {LFP '86},
	Title = {Integrating Functional and Imperative Programming},
	Url = {http://doi.acm.org/10.1145/319838.319848},
	Year = {1986},
	Bdsk-Url-1 = {http://doi.acm.org/10.1145/319838.319848},
	Bdsk-Url-2 = {https://doi.org/10.1145/319838.319848}}

@inproceedings{Yang:2006:CVM:1298455.1298466,
	Acmid = {1298466},
	Address = {Berkeley, CA, USA},
	Author = {Yang, Ting and Berger, Emery D. and Kaplan, Scott F. and Moss, J. Eliot B.},
	Booktitle = {Proceedings of the 7th Symposium on Operating Systems Design and Implementation},
	Date-Added = {2019-10-24 21:25:28 +0100},
	Date-Modified = {2019-10-24 21:25:28 +0100},
	Isbn = {1-931971-47-1},
	Location = {Seattle, Washington},
	Numpages = {14},
	Pages = {103--116},
	Publisher = {USENIX Association},
	Series = {OSDI '06},
	Title = {CRAMM: Virtual Memory Support for Garbage-collected Applications},
	Url = {http://dl.acm.org/citation.cfm?id=1298455.1298466},
	Year = {2006},
	Bdsk-Url-1 = {http://dl.acm.org/citation.cfm?id=1298455.1298466}}

@article{SchoeberlMartin2010Nrgc,
	Abstract = {<p><p>A real-time garbage collector has to fulfill two basic properties: ensure that programs with bounded allocation rates do not run out of memory and provide short blocking times. Even for incremental garbage collectors, two major sources of blocking exist, namely, root scanning and heap compaction. Finding root nodes of an object graph is an integral part of tracing garbage collectors and cannot be circumvented. Heap compaction is necessary to avoid probably unbounded heap fragmentation, which in turn would lead to unacceptably high memory consumption. In this article, we propose solutions to both issues.</p> <p>Thread stacks are local to a thread, and root scanning, therefore, only needs to be atomic with respect to the thread whose stack is scanned. This fact can be utilized by either blocking only the thread whose stack is scanned, or by delegating the responsibility for root scanning to the application threads. The latter solution eliminates blocking due to root scanning completely. The impact of this solution on the execution time of a garbage collector is shown for two different variants of such a root scanning algorithm.</p> <p>During heap compaction, objects are copied. Copying is usually performed atomically to avoid interference with application threads, which could render the state of an object inconsistent. Copying of large objects and especially large arrays introduces long blocking times that are unacceptable for real-time systems. In this article, an interruptible copy unit is presented that implements nonblocking object copy. The unit can be interrupted after a single word move.</p> <p>We evaluate a real-time garbage collector that uses the proposed techniques on a Java processor. With this garbage collector, it is possible to run high-priority hard real-time tasks at 10 kHz parallel to the garbage collection task on a 100 MHz system.</p></p>},
	Author = {Schoeberl, Martin and Puffitsch, Wolfgang},
	Date-Added = {2019-10-24 21:13:35 +0100},
	Date-Modified = {2019-10-24 21:13:35 +0100},
	Issn = {15399087},
	Journal = {ACM Transactions on Embedded Computing Systems (TECS)},
	Keywords = {Garbage Collection ; Nonblocking Copying ; Real-Time ; Root Scanning ; Engineering},
	Language = {eng},
	Number = {1},
	Pages = {1--28},
	Publisher = {ACM},
	Title = {Nonblocking real-time garbage collection},
	Volume = {10},
	Year = {2010}}

@article{KaliberaTomas2011Srgc,
	Abstract = {<p><p>Managed languages such as Java and C# are increasingly being considered for hard real-time applications because of their productivity and software engineering advantages. Automatic memory management, or garbage collection, is a key enabler for robust, reusable libraries, yet remains a challenge for analysis and implementation of real-time execution environments. This article comprehensively compares leading approaches to hard real-time garbage collection. There are many design decisions involved in selecting a real-time garbage collection algorithm. For time-based garbage collectors on uniprocessors one must choose whether to use <i>periodic</i>, <i>slack-based</i> or <i>hybrid</i> scheduling. A significant impediment to valid experimental comparison of such choices is that commercial implementations use completely different proprietary infrastructures. We present Minuteman, a framework for experimenting with real-time collection algorithms in the context of a high-performance execution environment for real-time Java. We provide the first comparison of the approaches, both experimentally using realistic workloads, and analytically in terms of schedulability.</p></p>},
	Author = {Kalibera, Tomas and Pizlo, Filip and Hosking, Antony and Vitek, Jan},
	Date-Added = {2019-10-24 20:54:58 +0100},
	Date-Modified = {2019-10-24 20:54:58 +0100},
	Issn = {07342071},
	Journal = {ACM Transactions on Computer Systems (TOCS)},
	Keywords = {Joint Scheduling ; Real-Time Garbage Collection ; Computer Science},
	Language = {eng},
	Number = {3},
	Pages = {1--29},
	Publisher = {ACM},
	Title = {Scheduling real-time garbage collection on uniprocessors},
	Volume = {29},
	Year = {2011}}

@inproceedings{SiebertF.2010Cprg,
	Author = {Siebert, F.},
	Copyright = {Copyright 2011 Elsevier B.V., All rights reserved.},
	Date-Added = {2019-10-24 19:15:13 +0100},
	Date-Modified = {2019-10-24 19:15:13 +0100},
	Issn = {15232867},
	Journal = {ACM SIGPLAN Notices},
	Keywords = {Concurrent ; Garbage Collection ; Java ; Multicore ; Parallel ; Real-Time},
	Number = {8},
	Pages = {11--20},
	Title = {Concurrent, parallel, real-time garbage-collection},
	Volume = {45},
	Year = {2010}}

@mastersthesis{knight-lisp,
	Author = {Thomas F. Knight, Jr},
	Date-Added = {2019-10-24 15:56:04 +0100},
	Date-Modified = {2019-10-24 15:57:29 +0100},
	Keywords = {Lisp; Computer Science},
	Month = {January},
	School = {Massachusetts Institute of Technology},
	Title = {Implementation of a List Processing Machine},
	Year = {1979}}

@misc{ai-memo-39,
	Author = {Tim Hart and Mike Levin},
	Date-Added = {2019-10-24 14:24:47 +0100},
	Date-Modified = {2019-10-24 15:02:58 +0100},
	Howpublished = {\url{ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-039.pdf}},
	Keywords = {Computer Science; Lisp; Compiler},
	Title = {AI Memo 39 - The New Compiler},
	Year = {1962}}

@article{MccarthyJohn1960Rfos,
	Author = {McCarthy, John},
	Date-Added = {2019-10-24 13:46:24 +0100},
	Date-Modified = {2019-10-24 15:00:23 +0100},
	Issn = {00010782},
	Journal = {Communications of the ACM},
	Keywords = {Engineering ; Computer Science ; Mathematics},
	Language = {eng},
	Number = {4},
	Pages = {184--195},
	Publisher = {ACM},
	Title = {Recursive functions of symbolic expressions and their computation by machine, Part I},
	Volume = {3},
	Year = {1960}}

@inproceedings{PearsonM.P1992AdLp,
	Abstract = {<p>The implementation details of a Lisp environment built on top of a distributed operating system are presented. The system provides transparent distribution, protected large-grain persistent heaps, concurrency within each environment and seamless sharing of Lisp data structures between separate environments.<<ETX>></p>},
	Author = {Pearson, M.P and Dasgupta, P},
	Booktitle = {[1992] Proceedings of the 12th International Conference on Distributed Computing Systems},
	Date-Added = {2019-10-23 22:13:50 +0100},
	Date-Modified = {2019-10-23 22:13:50 +0100},
	Isbn = {0818628650},
	Keywords = {Distributed Computing ; Concurrent Computing ; Data Structures ; Runtime Environment ; Educational Institutions ; Protection ; Workstations ; Hardware ; Programming Profession ; Terminology},
	Language = {eng},
	Pages = {690--697},
	Publisher = {IEEE Comput. Soc. Press},
	Title = {A distributed Lisp programming system: implementation and usage},
	Volume = {1992-},
	Year = {1992}}

@article{TakeuchiIkuo2002TfoL,
	Abstract = {Lisp has taken root widely and deeply in various fields, despite the decline of the AI fever in the 1980s and the common belief that Lisp has long been only a laboratory programming language. In the age of heterogeneous parallel computing, certain languages will survive and consolidate their positions. Lisp is surely classified among these languages. Moreover, Lisp has the potential to be a good system programming language, even suitable for writing an operating system, if real‚Äêtime garbage collection technology is further matured. {\copyright} 2002 Wiley Periodicals, Inc. Syst Comp Jpn, 33(6): 10--18, 2002; Published online in Wiley InterScience (). DOI 10.1002/scj.10000},
	Address = {New York},
	Author = {Takeuchi, Ikuo},
	Date-Added = {2019-10-23 22:02:40 +0100},
	Date-Modified = {2019-10-23 22:02:40 +0100},
	Issn = {0882-1666},
	Journal = {Systems and Computers in Japan},
	Keywords = {Lisp ; Symbolic Processing ; Real Time ; Garbage Collection ; Dynamic Language.},
	Language = {eng},
	Number = {6},
	Pages = {10--18},
	Publisher = {Wiley Subscription Services, Inc., A Wiley Company},
	Title = {The future of Lisp},
	Volume = {33},
	Year = {2002}}

@article{WalkerJ1987TSGP,
	Abstract = {This Lisp-based system helps designers get from prototype to product faster. The key is an open architecture and highly integrated development tools.},
	Address = {Los Alamitos},
	Author = {Walker, J and Moon, D and Weinreb, D and Mcmahon, M},
	Date-Added = {2019-10-23 21:58:37 +0100},
	Date-Modified = {2019-10-23 21:58:37 +0100},
	Issn = {07407459},
	Journal = {IEEE Software},
	Keywords = {Operating Systems (Software) ; Programming Languages;},
	Language = {eng},
	Number = {6},
	Pages = {36--45},
	Publisher = {IEEE Computer Society},
	Title = {The Symbolics Genera Programming Environment},
	Url = {http://search.proquest.com/docview/215842255/},
	Volume = {4},
	Year = {1987},
	Bdsk-Url-1 = {http://search.proquest.com/docview/215842255/}}

@article{YangJean2011Sttl,
	Author = {Yang, Jean and Hawblitzel, Chris},
	Date-Added = {2019-10-23 21:47:54 +0100},
	Date-Modified = {2019-10-23 21:47:54 +0100},
	Issn = {00010782},
	Journal = {Communications of the ACM},
	Keywords = {Engineering ; Computer Science ; Mathematics},
	Language = {eng},
	Number = {12},
	Pages = {123--131},
	Publisher = {ACM},
	Title = {Safe to the last instruction: automated verification of a type-safe operating system},
	Volume = {54},
	Year = {2011}}

@article{WhiteJon1987Amfa,
	Abstract = {<p><p>The possibility of incredibly cheap, fantastically large media for storage gives rise to a realistic LISP memory management scheme under which GC may be postponed for days, or even indefinitely; the idea is encapsulated in the acronym "DDI" --- "GC? Don't Do It!". Tertiary memory is used to archive pages of the LISP environment which are perhaps reclaimable. but which have not been proven so; whereas the standard technique of "paging" is used to swap active data from the main memory to a secondary store such as magnetic disk. Some scenarios are presented considering a variety of currently-available technologies, and of one speculative possibility --- videodisc --- by which a requisite compactifying GC would be done "overnight", or over the weekend. With enough tertiary available, one design could last for over 12 years without a GC. "Write-once" memories, probably unusable for most applications, would not be at a disadvantage here.</p></p>},
	Author = {White, Jon},
	Date-Added = {2019-10-21 14:49:14 +0100},
	Date-Modified = {2019-10-21 14:49:14 +0100},
	Issn = {1045-3563},
	Journal = {ACM SIGPLAN Lisp Pointers},
	Keywords = {Computer Science},
	Language = {eng},
	Number = {3},
	Pages = {17--25},
	Publisher = {ACM},
	Title = {Address/memory management for a gigantic LISP environment or, GC considered harmful},
	Volume = {1},
	Year = {1987}}
