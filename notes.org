* Project Planning
** DONE Which Architecture?
- ARM
- x86
- other?
** Watch out for
*** Paging
*** Interrupts
** DONE Toolchain
*** Cross Compiler
*** QEMU
*** test machine??
** OS Problems
- reliability
- security
- power use
- speed
- multi core speed
** Ideas
*** declarative OS
- declarative configuration
- increased configurability
- reliable and reproducible state  
*** better multi core OS
*** minimal side effects OS
*** transactional OS


* Links
- https://wiki.osdev.org/Expanded_Main_Page
- https://github.com/littlekernel/lk
- https://github.com/SerenityOS/serenity

- fonts: https://github.com/Tecate/bitmap-fonts/tree/master/screenshots

- booting:  https://www.gnu.org/software/grub/manual/multiboot/multiboot.html


* OS Planning
** Principles
- Lisp as primary language
- Immutable data structures first
- Memory is large, don't worry about it
- Lisp process consists of 'env' and code sections
** TODO Scheduler
- calculate avg wait and turnaround time
*** Round robin
** TODO Process Model
*** Header
- id, name
- compiled?
- should be on the fly compiled?
*** Env
- hashmap
- global vars and consts
**** code metadata
- special entry
- list of functions, their relative addrs, and init func
*** Stack
- lexically scoped vars
*** Code (List)
- Lisp List functions
*** Code (compiled)
- Lisp compiled
*** Thread Model
- read only access to env, return 
** TODO Memory Management
- SDM vol3 3
*** TODO malloc
- needs tidying/more sanity checks
- needs bitmap
- needs block merging
*** free
- find block specified, mark as free
*** Memory Map
- kernel space: fixed
- user space: grows upwards
*** Segmentation
- SDM vol3 3.2
- add *segment descriptor* to GDT
- 4 segments:
  kernel code
  kernel data
  userspace code
  userspace data
*** Paging
- track pages with AVL tree
- page table
- swap pages/page faults
** TODO Filesystem
*** ext2
*** serializable lisp
** TODO IO
*** keyboard
**** PS2 interface
*** mouse
** TODO Display
*** Terminal
**** printf
**** color management
**** control chars
**** high res terminal
*** Graphics
**** window system
- see rio, early X wms, blit terminal?
- simple design
**** screen setup
- using VESA/VGA modes
**** shape drawing library
**** GUI library
** TODO stdlib
*** klib
- better print/debug
- sprintf
*** lisp-interface-lib
- all kernel calls available from lisp
** TODO Tests
- add test feature to Makefile
- full coverage unit tests

** TODO Lisp
*** Kernelspace
*** C interaction
*** fundamenal functions
- [[https://stackoverflow.com/questions/3482389/how-many-primitives-does-it-take-to-build-a-lisp-machine-ten-seven-or-five/][stackoverflow question]]
*** low level interaction funcs
* Lisp Planning
- if they could do it on a PDP, you can do it too
** Parser
- no regex
- stateful, simple, fast
** VM
*** eval
- args: in_ast, env
- return: out_ast, env
*** eval_async
- env is read only
- args: in_ast
- return: out_ast
*** types
- atom, list
** Compiler
- equal results and interchangeable with VM
** Memory Layout
- word (32bit) pair of car and cdr for cons cell
- odd addr is car, even is cdr

* TODO Proposal
  SCHEDULED: <2019-10-21 Mon>
  


* Tasks
** malloc
- use linked list to store mem map
** segmentation
- basic flat model
** paging
- page allocator
- linked list or AVL Tree to store
- pages
** lisp
- write k realloc
- test c strings
- c lists 
*** parser
- loop
  create cons
    car:
        if token, car = token
        if (, car = loop on new cons
    cdr:
        if ), cdr = nil
        if token, cdr = loop on new cons
** interrupts
** multitasking
** userspace
** gui

#+BEGIN_SRC dot :cmd fdp :file arch.png
graph os_architecture {
    rank = "max";

    subgraph cluster_kernel {
        label = "Kernel";
    }
    
    subgraph cluster_lisp_vm {
        label = "Lisp VM"
	global_state;
	global_consts;
    }

    subgraph cluster_lisp_proc_a {
        label = "Lisp Process 1";
        code_a [label="Code"];
	env_a [label="Env"];
    }

    subgraph cluster_lisp_proc_b {
        label = "Lisp Process 2";
        code_b [label="Code"];
	env_b [label="Env"];
    }

    cluster_kernel -- cluster_lisp_vm;
    cluster_kernel -- cluster_lisp_proc_a;
    cluster_kernel -- cluster_lisp_proc_b;
}
#+END_SRC
#+RESULTS:
[[file:arch.png]]
