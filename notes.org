* DONE Project Planning
** DONE Which Architecture?
- ARM
- x86
- other?
** Watch out for
*** Paging
*** Interrupts
** DONE Toolchain
*** Cross Compiler
*** QEMU
*** test machine??
** Problems/Gaps
- Lisp Machines are dead, Lisp research dead
- but VM tech has improved (JIT compilers) (thanks java)

- concurrency is needed for further speed, single core won't get faster
- conventional shared mem concurrency is unsafe
- Functional programming/concurrency ensures safety
- x86 is not suited to lisp like languages (functional, dynamic)

- hence: a VM OS optimized for safe (functional) concurrency
** Ideas
*** declarative OS
- declarative configuration
- increased configurability
- reliable and reproducible state  
*** better multi core OS
*** minimal side effects OS
*** transactional OS

** Literature Survey
- identify gaps in research
- find references to *support* your observations
- this will lead to a stronger /background/ section
- reference list revauls the quality of your research

** plan search
- identify keywords (concurrency OS, multithreading, functional concurrency)
- date?

* Links
- https://wiki.osdev.org/Expanded_Main_Page
- https://github.com/littlekernel/lk
- https://github.com/SerenityOS/serenity

- fonts: https://github.com/Tecate/bitmap-fonts/tree/master/screenshots

- booting:  https://www.gnu.org/software/grub/manual/multiboot/multiboot.html

* OS Plan
** Principles
- Lisp as primary language
- Immutable data structures first
- Memory is large, don't worry about it
- Lisp process consists of 'env' and code sections
** Scheduler
- calculate avg wait and turnaround time
- mark lisp processes for JIT
*** Round robin
** Process Model
*** Header
- id, name
- compiled?
- should be on the fly compiled?
*** Env
- just use a list initally (BAD)
- hashmap
- global vars, consts, functions in current scope
*** Stack
- lexically scoped vars
*** Code (List)
- Lisp List functions
*** Code (compiled)
- Lisp compiled
*** Thread Model
- children share parents env in a read only form
- children have their own private mutable envcat
** Memory Management
- SDM vol3 3
*** malloc
- needs tidying/more sanity checks
- needs bitmap
- needs block merging
*** free
- find block specified, mark as free
*** Memory Map
- kernel space: fixed
- kernel starts at 0x100000
- user space: grows upwards
*** Segmentation
- SDM vol3 3.2
- add *segment descriptor* to GDT
- 4 segments:
  kernel code
  kernel data
  userspace code
  userspace data
*** Paging
- track pages with AVL tree
- page table
- swap pages/page faults
** TODO Filesystem
*** ext2
*** serializable lisp
** TODO IO
*** keyboard
**** PS2 interface
*** mouse
** TODO Display
*** Terminal
**** printf
**** color management
**** control chars
**** high res terminal
*** Graphics
**** window system
- see rio, early X wms, blit terminal?
- simple design
**** screen setup
- using VESA/VGA modes
**** shape drawing library
**** GUI library
** TODO stdlib
*** klib
- better print/debug
- sprintf
*** lisp-interface-lib
- all kernel calls available from lisp
** TODO Tests
- add test feature to Makefile
- full coverage unit tests

** TODO Lisp
*** Kernel REPL
*** fundamenal functions
- [[https://stackoverflow.com/questions/3482389/how-many-primitives-does-it-take-to-build-a-lisp-machine-ten-seven-or-five/][stackoverflow question]]
*** low level interaction funcs
* Lisp Planning
- if they could do it on a PDP, you can do it too
** Parser
- no regex
- stateful, simple, fast
** VM
*** eval
- args: in_ast, env
- return: out_ast, env
*** eval_async
- env is read only
- args: in_ast
- return: out_ast
*** types
- atom, list
** Compiler
- equal results and interchangeable with VM
** Memory Layout
- word (32bit) pair of car and cdr for cons cell
- odd addr is car, even is cdr
** Native Calls
- in env a native functions value is a function pointer to a C function
*** kernel env
- premade env with native functions for kprint, inb/outb, peek/poke
- a repl can run in kernel
- allows writing drivers in lisp
* DONE Proposal
  SCHEDULED: <2019-10-21 Mon>
** Intro
** Background
-  yang et al (p103-yang.pdf) virtual memory support for gargage collected applications 
- 
** Impl
** Work Plan
** Resources Required

* Tasks
** all
- rewrite structs to use snake_case
- switch to NASM?
** malloc
- use linked list to store mem map
** segmentation
- basic flat model
- none?
** paging
- page allocator
- linked list or AVL Tree to store
- pages
** lisp
- test c strings
- test c lists 
*** data types
**** TODO rewrite s-exp to just have a basic lisp obj (cons_t)
- the s_exp wrapper is redundant
*** env
*** parser
- she doesn't like too many leading or trailing spaces
** interrupts
- write assembly macro for generic interrupt handler
- tell the PIC that we're handling interrupts now
- write keeb handler
** multitasking
** userspace
** gui
